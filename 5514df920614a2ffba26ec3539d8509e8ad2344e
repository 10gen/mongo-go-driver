{
  "comments": [
    {
      "key": {
        "uuid": "22707fb9_ba635b8c",
        "filename": "mongo/gridfs/bucket.go",
        "patchSetId": 2
      },
      "lineNbr": 510,
      "author": {
        "id": 1015552
      },
      "writtenOn": "2019-01-04T19:42:37Z",
      "side": 0,
      "message": "User supplied-chunk size was ignored previously.",
      "revId": "5514df920614a2ffba26ec3539d8509e8ad2344e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "146528d3_107be88c",
        "filename": "mongo/gridfs/bucket.go",
        "patchSetId": 2
      },
      "lineNbr": 510,
      "author": {
        "id": 1014410
      },
      "writtenOn": "2019-01-07T16:50:54Z",
      "side": 0,
      "message": "Can you explain why this is needed? We should be setting upload.chunkSize to any value the user specified through uo.ChunkSizeBytes. \n\n1. How does the new code fix the issue?\n\n2. I\u0027m not sure I see the need for the special case of (*uo.ChunkSizeBytes !\u003d DefaultCunkSize). What if the bucket was configured with a non-default chunk size but for this upload, the user wants to use DefaultChunkSize? The new code wouldn\u0027t end up using the user-supplied value, and would instead default to the bucket\u0027s chunk size.",
      "parentUuid": "22707fb9_ba635b8c",
      "revId": "5514df920614a2ffba26ec3539d8509e8ad2344e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1bd42b89_d207c77b",
        "filename": "mongo/gridfs/bucket.go",
        "patchSetId": 2
      },
      "lineNbr": 510,
      "author": {
        "id": 1015552
      },
      "writtenOn": "2019-01-07T17:13:03Z",
      "side": 0,
      "message": "uo.ChunkSizeBytes is never nil. MergeUploadOptions begins by initializing an UploadOptions object with ChunkSizeBytes set to DefaultChunkSize. Therefore if the user supplied the chunk size while creating the bucket and created the upload stream without options, uo.ChunkSizeBytes will be non-nil with a value of DefaultChunkSize and will overwrite b.chunkSize.\n\nI did not consider that edge case (point 2) however, so thanks for pointing that out! Maybe a better solution would be change MergeUploadOptions to initialize u without setting ChunkSizeBytes.",
      "parentUuid": "146528d3_107be88c",
      "revId": "5514df920614a2ffba26ec3539d8509e8ad2344e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43154ea5_85100081",
        "filename": "mongo/gridfs/download_stream.go",
        "patchSetId": 2
      },
      "lineNbr": 90,
      "author": {
        "id": 1015552
      },
      "writtenOn": "2019-01-04T19:42:37Z",
      "side": 0,
      "message": "If chunk size is \u003c len(p), 32 kB, then bytesCopied would always be \u003c len(p), so the loop in Read would continue and keep overwriting p.",
      "revId": "5514df920614a2ffba26ec3539d8509e8ad2344e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2186f617_6179defd",
        "filename": "mongo/gridfs/download_stream.go",
        "patchSetId": 2
      },
      "lineNbr": 200,
      "author": {
        "id": 1015552
      },
      "writtenOn": "2019-01-04T19:42:37Z",
      "side": 0,
      "message": "This was causing issues before because the last chunk in the upload buffer will have length \u003c chunkSize, even if it is not the last chunk in the file. I removed this requirement for now.",
      "revId": "5514df920614a2ffba26ec3539d8509e8ad2344e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8a0ad73_b2580685",
        "filename": "mongo/gridfs/upload_stream.go",
        "patchSetId": 2
      },
      "lineNbr": 108,
      "author": {
        "id": 1015552
      },
      "writtenOn": "2019-01-04T19:42:37Z",
      "side": 0,
      "message": "Pretty sure this for loop never actually looped - note that we break at the end. This causes problems when we are unable to copy all of p into us.buffer. Though we shift p to start at n, it is overwritten in the next call to Read in UploadFromStreamWithID.",
      "revId": "5514df920614a2ffba26ec3539d8509e8ad2344e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}