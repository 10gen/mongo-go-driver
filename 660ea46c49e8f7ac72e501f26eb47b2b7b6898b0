{
  "comments": [
    {
      "key": {
        "uuid": "f047b126_fd007dcd",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 6,
      "author": {
        "id": 1013853
      },
      "writtenOn": "2019-03-25T13:45:37Z",
      "side": 1,
      "message": "Deployment is the thing that BIC will implement to ensure it selects from the same couple of connections it needs?",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2b827d6_e13fa49f",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 6,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T14:39:52Z",
      "side": 1,
      "message": "That\u0027s right.",
      "parentUuid": "f047b126_fd007dcd",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6df476dc_557cf626",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T12:26:38Z",
      "side": 1,
      "message": "Terminology question: SDAM uses Topology.  Java and .NET (which came before SDAM) settled on Cluster.  Is Deployment representing a different concept, and if not, can we use a word that other drivers use?",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b572cd7_d4fa19b7",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T14:31:01Z",
      "side": 1,
      "message": "According to the SDAM specification a Deployment is \"[o]ne or more servers: either a standalone, a replica set, or one or more mongoses.\" while a Topology is \"[t]he state of the deployment: its type (standalone, replica set, or sharded), which servers are up, what type of servers they are, which is primary, and so on.\"\n\nI feel like a description.Topology is what aligns with the Topology definition, while Deployment here aligns with what the SDAM specification defines for that.",
      "parentUuid": "6df476dc_557cf626",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2d907aa1_885f132b",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T15:44:35Z",
      "side": 1,
      "message": "Yeah, that makes total sense now.",
      "parentUuid": "4b572cd7_d4fa19b7",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8df00ece_e8d746de",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 19,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T12:26:38Z",
      "side": 1,
      "message": "Consider adding\n\n      Description() description.Server\n\nThe Java driver needs this method for a few use cases  in contexts where the driver doesn\u0027t need to get a Connection. (e.g. determining whether to use sessions or not)",
      "range": {
        "startLine": 19,
        "startChar": 0,
        "endLine": 19,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8a63c3a_aa85049b",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 19,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T14:31:01Z",
      "side": 1,
      "message": "Since we won\u0027t select a server outside of Execute, I\u0027m not sure how useful this method would be in practice. For sessions, we\u0027ll have to use the description.Topology to determine if we can pass sessions in.",
      "parentUuid": "8df00ece_e8d746de",
      "range": {
        "startLine": 19,
        "startChar": 0,
        "endLine": 19,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "54f98ada_4372c53a",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 19,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T15:44:35Z",
      "side": 1,
      "message": "OK, let\u0027s see if we can get by without it and can always add it later if we find we need it during implementation.",
      "parentUuid": "a8a63c3a_aa85049b",
      "range": {
        "startLine": 19,
        "startChar": 0,
        "endLine": 19,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "31967998_0406928b",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 24,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T12:26:38Z",
      "side": 1,
      "message": "I think there should be some abstraction for the wire protocol itself.  If we think of MongoDB as fundamentally a request-response system that sends commands as BSON documents and receives responses as BSON documents, then it behooves us to model that abstraction in the driver, and not require every command to consider all the variances of wire protocol messages based on server version, compression, etc, and instead push all that down into the Connection implementation.\n\nIf we do that, then Connection could become something more like:\n\n     ExecuteCommand(context.Context, bson.Raw) bson.Raw, error  \n\nAnd we just have to handle the exceptions to that fundamental property, which at this point is just the three pre 3.2 wire query-related wire protocol messages.",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 24,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "312dcefd_e39350af",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 24,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T14:31:01Z",
      "side": 1,
      "message": "I\u0027d like to avoid this for a few reasons:\n\n- This abstraction requires the topology package to understand wire messages, which complicates a complex package.\n- It requires extra passes, for example iterating the command for the read preference and write concern to set flags or format the wire message differently.\n- We\u0027ll have to modify the bsoncore.Document that we receive in the case of of $db and $readPreference to remove them for OP_QUERY.\n- In the case of 2.6 and 3.0 servers, rewriting the entire command to fit within OP_QUERY and OP_GET_MORE indicates this might not be the right abstraction.\n\nWhile I see the appeal of adding a layer of abstraction between commands and wire messages, it winds up being a leaky abstraction.\n\nI\u0027m not sure what this abstraction gives us either. If we\u0027re worried about people having to handle wire messages directly, a few utility functions within the driver package should make pulling a command out of a wire message straightforward.",
      "parentUuid": "31967998_0406928b",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 24,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "53c238a2_04509755",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 24,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T15:44:35Z",
      "side": 1,
      "message": "* The complexity has to go somewhere.  I just ask that it be centralized, whether that\u0027s in Connection or in some internal layer in the drivers package.  Every operation implementation shouldn\u0027t have to contain the same conditionals around wire version, compression, etc.  FindOperation will need it because of the fundamental move from specific wire protocol message to command, but the rest of them would ideally be wire-protocol agnostic. \n* I\u0027m not sure what you mean, but I know it can be handled efficiently\n* We can treat those fields as part of the wire protocol and add them at the point the wire message is created\n* This is the ugly part, but long term it goes away as we drop support for older server versions.  There are a number of ways to handle it in the meantime so that it doesn\u0027t infect the whole driver.",
      "parentUuid": "312dcefd_e39350af",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 24,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdf44b6c_b2114dde",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 24,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T22:02:22Z",
      "side": 1,
      "message": "Discussed this offline. Added an open questions section about how much and what type of code we should be generating.",
      "parentUuid": "53c238a2_04509755",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 24,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2f0917c4_2d4ca6fd",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 24,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T22:11:35Z",
      "side": 1,
      "message": "Resolving this thread, as it\u0027s been added as an open question to be decided during implementation phase.",
      "parentUuid": "fdf44b6c_b2114dde",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 24,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "58fc5290_cbb53ccb",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 27,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T12:26:38Z",
      "side": 1,
      "message": "Assuming Close() returns the connection to the pool, consider adding a Disconnect (or Invalidate) method as well.  This will be necessary to support exhaust cursors that are not fully iterated by the application.  In that situation there will be an unknown number of responses waiting to be read, which makes the Connection unusable by future operations.  In that case it\u0027s probably best just to disconnect the socket, which requires the cursor to have a way to tell the Connection to do that rather than just put itself back in the pool.",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5f8065b_17bb177b",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 27,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T12:26:38Z",
      "side": 1,
      "message": "Will Close() return the connection to the pool, or actually close the socket?",
      "range": {
        "startLine": 27,
        "startChar": 0,
        "endLine": 27,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "171795be_ebde2d36",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 27,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T14:31:01Z",
      "side": 1,
      "message": "Assuming we only support exhaust cursors in OP_MSG, then we can track this information in the connection directly by reading the moreToCome bit. If a Connection is closed while the moreToCome bit is set then we throw away the Connection instead of putting it back in the pool.",
      "parentUuid": "58fc5290_cbb53ccb",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "78ad4739_d3cd5c91",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 27,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T14:31:01Z",
      "side": 1,
      "message": "That\u0027s an implementation specific detail and not covered here. In the topology.Connection implementation it will return it to the pool.",
      "parentUuid": "b5f8065b_17bb177b",
      "range": {
        "startLine": 27,
        "startChar": 0,
        "endLine": 27,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "828ccc42_16f4d525",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 27,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T15:44:35Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "78ad4739_d3cd5c91",
      "range": {
        "startLine": 27,
        "startChar": 0,
        "endLine": 27,
        "endChar": 1
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2fb600f0_f76b580f",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 27,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T15:44:35Z",
      "side": 1,
      "message": "Nice, I think that will work!",
      "parentUuid": "171795be_ebde2d36",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "caa56eea_aa856162",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 34,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T12:26:38Z",
      "side": 1,
      "message": "Nit: \"writes it to a `Connection`\"",
      "range": {
        "startLine": 34,
        "startChar": 81,
        "endLine": 34,
        "endChar": 87
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73144e7c_e2d544b4",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 34,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T22:11:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "caa56eea_aa856162",
      "range": {
        "startLine": 34,
        "startChar": 81,
        "endLine": 34,
        "endChar": 87
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "795b6d68_8250c204",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 38,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T12:26:38Z",
      "side": 1,
      "message": "Can you define these two interfaces in the design document?  It would make the example easier to understand.",
      "range": {
        "startLine": 38,
        "startChar": 11,
        "endLine": 38,
        "endChar": 19
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3724bb5a_afaf2c05",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 38,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T14:31:01Z",
      "side": 1,
      "message": "I\u0027ll add this to the updated design document. Also, there are three interfaces here: Selector, Executor, and RetryableExecutor.",
      "parentUuid": "795b6d68_8250c204",
      "range": {
        "startLine": 38,
        "startChar": 11,
        "endLine": 38,
        "endChar": 19
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37c43572_ec68a8d4",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 38,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T22:11:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3724bb5a_afaf2c05",
      "range": {
        "startLine": 38,
        "startChar": 11,
        "endLine": 38,
        "endChar": 19
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "70fc27ad_b71d775e",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 136,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T12:26:38Z",
      "side": 1,
      "message": "We may have to consider Session as something that is handled specially.  The reason is because unlike the rest of these types it represents a server resource, somewhat like a cursor, and for this reason an operation has to be able to indicate when it\u0027s done with the session.  Normally that\u0027s just when the operation completes, but in the case of operations that return cursors the session should not be returned to the session pool until the cursor is closed.\n\nThis can be handled similarly to Connection, where a Close method indicates that the operation is done with the Session.  A reference count may turn out to be more elegant, as it handles both implicit and explicit sessions similarly, where the latter just starts with a reference count of 1 indicating that the application holds a reference to it.",
      "range": {
        "startLine": 136,
        "startChar": 1,
        "endLine": 136,
        "endChar": 2
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89ec8280_6d490517",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 136,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T14:31:01Z",
      "side": 1,
      "message": "This package doesn\u0027t handle session pools, that\u0027s the consumer\u0027s responsibility. This package will error if an explicit session is passed in and the connection we get doesn\u0027t support sessions. If it\u0027s implicit we\u0027ll just ignore it. Other than that, the caller needs to handle the life cycle of the session. It makes sense for driver.BatchCursor to not close a session and leave that up to the mongo.Cursor implementation (if it even needs to close the session).\n\nI\u0027ll add information about this to the design.",
      "parentUuid": "70fc27ad_b71d775e",
      "range": {
        "startLine": 136,
        "startChar": 1,
        "endLine": 136,
        "endChar": 2
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "728a6976_6ca8b192",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 136,
      "author": {
        "id": 1013848
      },
      "writtenOn": "2019-03-25T15:44:35Z",
      "side": 1,
      "message": "About session pools: totally agree that it\u0027s not driver package responsibility\nAbout erroring: agree with that too\n\nI still think some sort of reference counting scheme will simplify the design, but I think I see how that can be done at the mongo layer.",
      "parentUuid": "89ec8280_6d490517",
      "range": {
        "startLine": 136,
        "startChar": 1,
        "endLine": 136,
        "endChar": 2
      },
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71da56e7_111b0a62",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1013853
      },
      "writtenOn": "2019-03-25T13:45:37Z",
      "side": 1,
      "message": "So all commands need access to this clock? Is there not an abstraction that can be added to keep commands ignorant of this requirement? I assume this is related to sessions, so at the very least, it seems they could be combined somehow.",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52740604_092ceb8a",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 137,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T14:39:52Z",
      "side": 1,
      "message": "Yes and no, respectively. The types are related but different. We have to update the mongo.Client\u0027s session.ClusterClock directly from the results of the command. Additionally, according to the sessions specification[1], we have to compare the cluster time from the session.Client and from the mongo.Client and use whichever is greater, so we need access to the mongo.Client\u0027s session.ClusterClock. We could create a session.ClusterClocks abstraction that encompasses multiple clocks, provides the greatest cluster time and allows for updating all of the clocks. However, we still need access to the session.Client directly to encode the lsid and set RetryWrites, so this abstraction doesn\u0027t actually remove the need for a field here.\n\n[1] https://github.com/mongodb/specifications/blob/master/source/sessions/driver-sessions.rst#how-to-compute-the-clustertime-to-send-to-a-server",
      "parentUuid": "71da56e7_111b0a62",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc77329b_61645c89",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 172,
      "author": {
        "id": 1013853
      },
      "writtenOn": "2019-03-25T13:45:37Z",
      "side": 1,
      "message": "This is called ClusterClock below in the FindOperation. Are these different or just a typo?",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ff7a358c_ed2d748b",
        "filename": "x/mongo/driverx/DESIGN.md",
        "patchSetId": 12
      },
      "lineNbr": 172,
      "author": {
        "id": 1001503
      },
      "writtenOn": "2019-03-25T14:39:52Z",
      "side": 1,
      "message": "They\u0027re the same, the struct tags are different between the two operations.",
      "parentUuid": "fc77329b_61645c89",
      "revId": "660ea46c49e8f7ac72e501f26eb47b2b7b6898b0",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}