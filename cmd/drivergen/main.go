package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const preamble = `// Copyright (C) MongoDB, Inc. 2017-present.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

// Code generated by drivergen. DO NOT EDIT.

`

// initialize handles loading packages and retrieving the type to be code generated.
func initialize(typename string) (*types.Struct, *ast.StructType, *types.Package, []*packages.Package, error) {
	pkgs, err := packages.Load(&packages.Config{Mode: packages.LoadAllSyntax}, knownPackages[:]...)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	// We load this package by itself, not sure how to pick out the current package from a
	// []*packages.Package.
	thispkg, err := packages.Load(&packages.Config{Mode: packages.LoadAllSyntax})
	if err != nil {
		return nil, nil, nil, nil, errors.New("Couldn't load package in current directory. Ensure the current directory contains .go files.")
	}

	if len(thispkg) != 1 {
		return nil, nil, nil, nil, errors.New("drivergen can currently only handle directories with one package.")
	}

	pkgpath := thispkg[0].PkgPath
	var ppkg *packages.Package
	for _, p := range pkgs {
		if p.PkgPath != pkgpath {
			continue
		}
		ppkg = p
		break
	}

	var stxObj *ast.Object
	for _, sfile := range ppkg.Syntax {
		obj := sfile.Scope.Lookup(typename)
		if obj == nil {
			continue
		}
		stxObj = obj
		break
	}

	if stxObj == nil {
		return nil, nil, nil, nil, fmt.Errorf("Couldn't find %s in the package.", typename)
	}

	ts, ok := stxObj.Decl.(*ast.TypeSpec)
	if !ok {
		return nil, nil, nil, nil, fmt.Errorf("%s if not a struct declaration.", typename)
	}

	syntaxStruct, ok := ts.Type.(*ast.StructType)
	if !ok {
		return nil, nil, nil, nil, fmt.Errorf("%s is not a struct type.", typename)
	}

	obj, ok := ppkg.TypesInfo.Defs[ts.Name]
	if !ok {
		return nil, nil, nil, nil, fmt.Errorf("Couldn't find %s in types definition.", typename)
	}

	pkg := ppkg.Types
	t, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		return nil, nil, nil, nil, fmt.Errorf("Type must be a struct, but it is a %s", obj.Type().Underlying())
	}

	return t, syntaxStruct, pkg, pkgs, nil
}

func main() {
	fs := flag.NewFlagSet("", flag.ExitOnError)
	fs.Usage = func() {
		fmt.Fprintln(fs.Output(), "drivergen is used to generate operation implementations.")
		fmt.Fprintln(fs.Output(), "usage: drivergen <type to generate> <generated file name>")
		fs.PrintDefaults()
	}
	var dryrun bool
	fs.BoolVar(&dryrun, "dryrun", false, "prints the output to stdout instead of writing to a file.")
	var usepointers bool
	fs.BoolVar(&usepointers, "use-pointers", false, "use pointer receivers for the generated methods and returns.")
	var constructorName string
	fs.StringVar(&constructorName, "constructor", "", "the name of the constructor. No constructor will be created if this is empty.")
	err := fs.Parse(os.Args[1:])
	if err == flag.ErrHelp {
		fs.Usage()
		os.Exit(0)
	}
	if err != nil {
		log.Fatalf("Could not parse flags: %v", err)
	}
	args := fs.Args()
	if len(args) < 2 {
		log.Println("Insufficient arguments specified.")
		fs.Usage()
		os.Exit(1)
	}
	filename := args[1]
	typename := args[0]

	t, syntaxStruct, pkg, pkgs, err := initialize(typename)
	if err != nil {
		log.Fatalf("Couldn't load packages: %v", err)
	}

	err = LoadKnownTypes(pkgs)
	if err != nil {
		log.Fatalf("Couldn't load known types: %v", err)
	}

	n := t.NumFields()
	fields := make(map[string]Field, n)
	docSequences := make(map[string]Field, 1)
	syntaxFields := syntaxStruct.Fields.List
	if len(syntaxFields) != n {
		log.Fatalf("Mismatch number of fields between syntax and type. syntax=%d type=%d", len(syntaxFields), n)
	}

	constructor := Constructor{Name: constructorName}
	operation := Operation{Receiver: receiverName(typename), TypeName: typename, Constructor: constructor}
	for i := 0; i < n; i++ {
		tag := parseTag(t.Tag(i))
		if tag.Skip {
			continue
		}
		f := t.Field(i)
		sf := syntaxFields[i]
		field := Field{
			ftype:         tag.Type,
			name:          f.Name(),
			field:         f,
			pointerExempt: tag.PointerExempt,
			variadic:      tag.Variadic,
		}

		if tag.ConstructorArg {
			constructor.ParamName = f.Name()
			constructor.ParamType = f
			constructor.Variadic = tag.Variadic
			operation.Constructor = constructor
		}
		switch field.ftype {
		case Setter:
			field.fnname = strings.Title(f.Name())
			if tag.Name != "" {
				field.fnname = tag.Name
			}
			if sf.Doc != nil && len(sf.Doc.List) > 0 {
				for _, line := range sf.Doc.List {
					field.doc = append(field.doc, line.Text)
				}
			}
			if _, exists := fields[field.fnname]; exists {
				log.Fatalf("Duplicate name found: %s", field.fnname)
			}

			t := f.Type()
			if ptr, ok := t.(*types.Pointer); ok {
				t = ptr.Elem()
			}
			switch t {
			case Deployment:
				field.knownType = KTDeployment
				operation.Deployment = &field
			case ServerSelector:
				field.knownType = KTServerSelector
				operation.ServerSelector = &field
			case Namespace:
				field.knownType = KTNamespace
				operation.Namespace = &field
			case RetryMode:
				field.knownType = KTRetryMode
				if !tag.RetryableWrite {
					log.Fatalf("Field %s is of known type RetryMode but does not specify retryableWrite", field.name)
				}
				operation.RetryWrite = &field
			case WriteConcern:
				field.knownType = KTWriteConcern
				field.pointerExempt = true
				operation.WriteConcern = &field
			case ReadConcern:
				field.knownType = KTReadConcern
				field.pointerExempt = true
				operation.ReadConcern = &field
			case ReadPreference:
				field.knownType = KTReadPreference
				field.pointerExempt = true
				operation.ReadPreference = &field
			case ClientSession:
				field.knownType = KTClientSession
				field.pointerExempt = true
				operation.ClientSession = &field
			case ClusterClock:
				field.knownType = KTClusterClock
				field.pointerExempt = true
				operation.ClusterClock = &field
			}
			fields[field.fnname] = field
		case CommandName:
		case DocumentSequence:
			if tag.Name != "" {
				field.name = tag.Name
			}
			if _, exists := docSequences[field.name]; exists {
				log.Fatalf("Duplicate document sequence name found: %s", field.name)
			}
			docSequences[field.name] = field
		}
	}

	err = operation.Validate()
	if err != nil {
		log.Fatalf("Couldn't validate the %s Operation: %v", typename, err)
	}

	var b bytes.Buffer
	b.WriteString(preamble)
	fmt.Fprintln(&b, "package ", pkg.Name())

	if constructor.Name != "" {
		var pname string
		var ptype string
		if constructor.ParamName != "" && constructor.ParamType != nil {
			pname = constructor.ParamName
			ptype = types.TypeString(constructor.ParamType.Type(), types.Qualifier(func(p *types.Package) string {
				if p == pkg {
					return ""
				}
				return p.Name()
			}))

			if constructor.Variadic {
				ptype = strings.Replace(ptype, "[]", "...", 1)
			}
		}
		fmt.Fprintf(&b, "// %s constructs and returns a new %s.\n", constructor.Name, typename)
		fmt.Fprintf(&b, "func %s(%s %s) *%s {\n", constructor.Name, pname, ptype, typename)
		fmt.Fprintf(&b, "return &%s{", typename)
		if pname != "" && ptype != "" {
			fmt.Fprintf(&b, "%s: %s", pname, pname)
		}
		fmt.Fprintln(&b, "}")
		fmt.Fprintln(&b, "}")
	}

	sd := SelectData{
		Receiver:   operation.Receiver,
		Type:       operation.TypeName,
		Deployment: operation.Deployment.name,
		Selector:   operation.ServerSelector.name,
	}
	if operation.ReadPreference != nil {
		sd.ReadPref = operation.ReadPreference.name
	}

	ed := ExecuteData{
		Receiver:   operation.Receiver,
		Type:       operation.TypeName,
		Deployment: operation.Deployment.name,
	}

	if operation.RetryWrite != nil {
		ed.RetryWrite = operation.RetryWrite.name
	}
	if operation.ClientSession != nil {
		ed.ClientSession = operation.ClientSession.name
	}
	if operation.WriteConcern != nil {
		ed.WriteConcern = operation.WriteConcern.name
	}

	tmpls := []tmpl{
		{"Select", selectTmpl, sd},
		{"SelectAndExecute", selectAndExecuteTmpl, SelectAndExecuteData{Receiver: operation.Receiver, Type: operation.TypeName}},
		{"Execute", executeTmpl, ed},
	}
	if operation.RetryWrite != nil {
		red := RetryExecuteData{
			Receiver:      operation.Receiver,
			Type:          operation.TypeName,
			ClientSession: operation.ClientSession.name,
			Deployment:    operation.Deployment.name,
		}
		if operation.WriteConcern != nil {
			red.WriteConcern = operation.WriteConcern.name
		}
		tmpls = append(
			tmpls,
			tmpl{"SelectAndRetryExecute", selectAndRetryExecuteTmpl, SelectAndRetryExecuteData{Receiver: operation.Receiver, Type: operation.TypeName}},
			tmpl{"RetryExecute", retryExecuteTmpl, red},
		)
	}
	err = executeTemplates(&b, tmpls)
	if err != nil {
		log.Fatalf("Couldn't generate methods: %v", err)
	}

	generateSetters(&b, pkg, fields, typename, usepointers)

	buf, err := imports.Process(filename, b.Bytes(), nil)
	if err != nil {
		log.Fatalf("Could not run goimports on generated source: %v", err)
	}

	if dryrun {
		os.Stdout.Write(buf)
		os.Exit(0)
	}
	file, err := os.Create(filename)
	if err != nil {
		log.Fatalf("Could not create %s: %v", filename, err)
	}

	_, err = file.Write(buf)
	if err != nil {
		log.Fatalf("Could not write to %s: %v", filename, err)
	}
}

type tmpl struct {
	name     string
	template string
	data     interface{}
}

func executeTemplates(b *bytes.Buffer, tmpls []tmpl) error {
	for _, t := range tmpls {
		tt, err := template.New("").Parse(t.template)
		if err != nil {
			return fmt.Errorf("couldn't parse %s template: %v", t.name, err)
		}
		err = tt.Execute(b, t.data)
		if err != nil {
			return fmt.Errorf("couldn't execute %s template: %v", t.name, err)
		}
	}
	return nil
}

func generateSetters(b *bytes.Buffer, pkg *types.Package, fields map[string]Field, typename string, usepointers bool) {
	fieldslc := fieldSliceFromMap(fields)
	short := receiverName(typename)

	receiver := typename
	if usepointers {
		receiver = "*" + typename
	}
	for _, field := range fieldslc {
		tt := field.field.Type()
		setter := field.name
		if ptt, ok := tt.(*types.Pointer); ok && !field.pointerExempt {
			tt = ptt.Elem()
			setter = "&" + field.name
		}
		param := types.TypeString(tt, types.Qualifier(func(p *types.Package) string {
			if p == pkg {
				return ""
			}
			return p.Name()
		}))

		if field.variadic {
			param = strings.Replace(param, "[]", "...", 1)
		}

		fmt.Fprintln(b, strings.Join(field.doc, "\n"))
		fmt.Fprintf(b, "func (%s %s) %s(%s %s) %s {\n", short, receiver, field.fnname, field.name, param, receiver)
		if usepointers {
			fmt.Fprintf(b, "if %s == nil {\n", short)
			fmt.Fprintf(b, "%s = new(%s)", short, typename)
			fmt.Fprint(b, "}\n\n")
		}
		fmt.Fprintf(b, "%s.%s = %s\n", short, field.name, setter)
		fmt.Fprintf(b, "return %s\n", short)
		fmt.Fprint(b, "}\n\n")
	}
}

type Constructor struct {
	Name      string
	ParamName string
	ParamType *types.Var
	Variadic  bool
}

func receiverName(name string) string {
	if len(name) == 0 {
		return ""
	}
	short := strings.ToLower(string(name[0]))
	idx := 1
	for {
		i := strings.IndexFunc(name[idx:], unicode.IsUpper)
		if i == -1 {
			break
		}
		idx += i
		short += strings.ToLower(string(name[idx]))
		idx++
	}
	return short
}
