package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"log"
	"os"
	"reflect"
	"sort"
	"strings"
	"unicode"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const preamble = `// Copyright (C) MongoDB, Inc. 2017-present.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

// Code generated by drivergen. DO NOT EDIT.

`

func main() {
	fs := flag.NewFlagSet("", flag.ExitOnError)
	fs.Usage = func() {
		fmt.Fprintln(fs.Output(), "drivergen is used to generate operation implementations.")
		fmt.Fprintln(fs.Output(), "usage: drivergen <type to generate> <generated file name>")
		fs.PrintDefaults()
	}
	var dryrun bool
	fs.BoolVar(&dryrun, "dryrun", false, "prints the output to stdout instead of writing to a file.")
	var usepointers bool
	fs.BoolVar(&usepointers, "use-pointers", false, "use pointer receivers for the generated methods and returns.")
	err := fs.Parse(os.Args[1:])
	if err == flag.ErrHelp {
		fs.Usage()
		os.Exit(0)
	}
	if err != nil {
		log.Fatalf("Could not parse flags: %v", err)
	}
	args := fs.Args()
	if len(args) < 2 {
		log.Println("Insufficient arguments specified.")
		fs.Usage()
		os.Exit(1)
	}
	filename := args[1]
	typename := args[0]

	pkgs, err := packages.Load(&packages.Config{Mode: packages.LoadAllSyntax})
	if err != nil {
		log.Fatal("Couldn't load package in current directory. Ensure the current directory contains .go files.")
	}

	if len(pkgs) != 1 {
		log.Fatal("drivergen can currently only handle directories with one package.")
	}

	var stxObj *ast.Object
	for _, sfile := range pkgs[0].Syntax {
		obj := sfile.Scope.Lookup(typename)
		if obj == nil {
			continue
		}
		stxObj = obj
		break
	}

	if stxObj == nil {
		log.Fatalf("Couldn't find %s in the package.", typename)
	}

	ts, ok := stxObj.Decl.(*ast.TypeSpec)
	if !ok {
		log.Fatalf("%s if not a struct declaration.", typename)
	}

	syntaxStruct, ok := ts.Type.(*ast.StructType)
	if !ok {
		log.Fatalf("%s is not a struct type.", typename)
	}

	obj, ok := pkgs[0].TypesInfo.Defs[ts.Name]
	if !ok {
		log.Fatalf("Couldn't find %s in types definition.", typename)
	}

	pkg := pkgs[0].Types
	t, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		log.Fatalf("Type must be a struct, but it is a %s", obj.Type().Underlying())
	}
	n := t.NumFields()
	fields := make(map[string]Field, n)
	docSequences := make(map[string]Field, 1)
	syntaxFields := syntaxStruct.Fields.List
	if len(syntaxFields) != n {
		log.Fatalf("Mismatch number of fields between syntax and type. syntax=%d type=%d", len(syntaxFields), n)
	}

	for i := 0; i < n; i++ {
		tag := parseTag(t.Tag(i))
		if tag.Skip {
			continue
		}
		f := t.Field(i)
		sf := syntaxFields[i]
		field := Field{
			ftype:         tag.Type,
			name:          f.Name(),
			field:         f,
			pointerExempt: tag.PointerExempt,
			variadic:      tag.Variadic,
		}
		switch field.ftype {
		case Setter:
			field.fnname = strings.Title(f.Name())
			if tag.Name != "" {
				field.fnname = tag.Name
			}
			if sf.Doc != nil && len(sf.Doc.List) > 0 {
				for _, line := range sf.Doc.List {
					field.doc = append(field.doc, line.Text)
				}
			}
			if _, exists := fields[field.fnname]; exists {
				log.Fatalf("Duplicate name found: %s", field.fnname)
			}
			fields[field.fnname] = field
		case CommandName:
		case DocumentSequence:
			if tag.Name != "" {
				field.name = tag.Name
			}
			if _, exists := docSequences[field.name]; exists {
				log.Fatalf("Duplicate document sequence name found: %s", field.name)
			}
			docSequences[field.name] = field
		}
	}

	var b bytes.Buffer
	b.WriteString(preamble)
	fmt.Fprintln(&b, "package ", pkgs[0].Name)

	generateSetters(&b, pkg, fields, typename, usepointers)

	buf, err := imports.Process(filename, b.Bytes(), nil)
	if err != nil {
		log.Fatalf("Could not run goimports on generated source: %v", err)
	}

	if dryrun {
		os.Stdout.Write(buf)
		os.Exit(0)
	}
	file, err := os.Create(filename)
	if err != nil {
		log.Fatalf("Could not create %s: %v", filename, err)
	}

	_, err = file.Write(buf)
	if err != nil {
		log.Fatalf("Could not write to %s: %v", filename, err)
	}
}

func generateSetters(b *bytes.Buffer, pkg *types.Package, fields map[string]Field, typename string, usepointers bool) {
	fieldslc := fieldSliceFromMap(fields)
	short := receiverName(typename)

	receiver := typename
	if usepointers {
		receiver = "*" + typename
	}
	for _, field := range fieldslc {
		tt := field.field.Type()
		setter := field.name
		if ptt, ok := tt.(*types.Pointer); ok && !field.pointerExempt {
			tt = ptt.Elem()
			setter = "&" + field.name
		}
		param := types.TypeString(tt, types.Qualifier(func(p *types.Package) string {
			if p.String() == pkg.String() {
				return ""
			}
			return p.Name()
		}))

		if field.variadic {
			param = strings.Replace(param, "[]", "...", 1)
		}

		fmt.Fprintln(b, strings.Join(field.doc, "\n"))
		fmt.Fprintf(b, "func (%s %s) %s(%s %s) %s {\n", short, receiver, field.fnname, field.name, param, receiver)
		if usepointers {
			fmt.Fprintf(b, "if %s == nil {\n", short)
			fmt.Fprintf(b, "%s = new(%s)", short, typename)
			fmt.Fprint(b, "}\n\n")
		}
		fmt.Fprintf(b, "%s.%s = %s\n", short, field.name, setter)
		fmt.Fprintf(b, "return %s\n", short)
		fmt.Fprint(b, "}\n\n")
	}
}

const createMsgWireMessageTmpl = `
func ({{.Short}} {{.TypeName}}) createMsgWireMessage(dst []byte, desc description.SelectedServer) ([]byte, error) {
	var flags wiremessage.MsgFlag
	var wmindex int32
	wmindex, dst = wiremessagex.AppendHeaderStart(dst, wiremessage.NextRequestID(), 0, wiremessage.OpMsg)
	dst = wiremessagex.AppendMsgFlags(dst, flags)

	dst = wiremessagex.AppendMsgSectionType(dst, wiremessage.SingleDocument)
	idx, dst := bsoncore.AppendDocumentStart(dst)

	// TODO(GODRIVER-617): Replace this with a subtemplate for setting the command name and
	// collection. This will differ for some commands, e.g. aggregate on a database has the value as
	// an int32 of 1.
	dst = bsoncore.AppendStringElement(dst, "{{.CommandName}}", {{.Short}}.{{.Namespace}}.Collection)

	{{ range .Parameters }}
	{{ end }}

	{{ if .WriteConcern }}
	dst, err := addWriteConcern(dst, {{.Short}}.{{.WriteConcern}})
	if err != nil {
		return dst, err
	}
	{{ end }}
	{{ if .Session }}
	dst, err = addSession(dst, {{.Short}}.{{.Session}}, desc)
	if err != nil {
		return dst, err
	}
	{{ if .RetryWrite }}
	if {{.Short}}.{{.Session}}.RetryWrite {
		dst = bsoncore.AppendInt64Element(dst, "txnNumber", {{.Short}}.{{.Session}}.TxnNumber)
	}
	{{ with $clock := or .Clock "nil" }}
	dst = addClusterTime(dst, {{.Short}}.{{.Session}}, {{ printf "%s" $clock }}, desc)
	{{ end }}
	{{ end }}

	dst = bsoncore.AppendStringElement(dst, "$db", {{.Short}}.{{.Namespace}}.DB)

	dst, _ = bsoncore.AppendDocumentEnd(dst, idx)

	{{ range .Sequences }}
	dst = wiremessagex.AppendMsgSectionType(dst, wiremessage.DocumentSequence)
	idx, dst = bsoncore.ReserveLength(dst)

	dst = append(dst, {{.Name}}[:]...)

	for _, doc := range {{$.Short}}.{{.Field}} {
		dst = append(dst, doc...)
	}

	dst = bsoncore.UpdateLength(dst, idx, int32(len(dst[idx:])))
	{{ end }}

	return bsoncore.UpdateLength(dst, wmindex, int32(len(dst[wmindex:]))), nil
}
`

func createMsgWireMessage() {
	return
}

type Field struct {
	ftype         TagType
	field         *types.Var
	fnname        string
	name          string
	doc           []string
	pointerExempt bool
	variadic      bool
}

type FieldSlice []Field

var _ sort.Interface = (FieldSlice)(nil)

// fieldSliceFromMap converts a map into a FieldSlice. The returned FieldSlice is sorted by Field.name.
func fieldSliceFromMap(m map[string]Field) FieldSlice {
	fs := make(FieldSlice, 0, len(m))
	for _, field := range m {
		fs = append(fs, field)
	}
	sort.Sort(fs)
	return fs
}

func (f FieldSlice) Len() int           { return len(f) }
func (f FieldSlice) Less(i, j int) bool { return f[i].name < f[j].name }
func (f FieldSlice) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }

type TagType uint

const (
	Setter TagType = iota
	CommandName
	DocumentSequence
)

type Tag struct {
	Type          TagType
	Skip          bool
	Name          string
	PointerExempt bool
	Variadic      bool
}

func parseTag(str string) Tag {
	tag, ok := reflect.StructTag(str).Lookup("drivergen")
	if !ok && !strings.Contains(string(str), ":") && len(str) > 0 {
		tag = str
	}
	var t Tag
	if tag == "-" {
		t.Skip = true
		return t
	}

	for idx, s := range strings.Split(tag, ",") {
		if idx == 0 && s != "" {
			t.Name = s
		}
		switch s {
		case "pointerExempt":
			t.PointerExempt = true
		case "variadic":
			t.Variadic = true
		case "commandName":
			t.Type = CommandName
		case "msgDocSeq":
			t.Type = DocumentSequence
		}
	}

	return t
}

func receiverName(name string) string {
	if len(name) == 0 {
		return ""
	}
	short := strings.ToLower(string(name[0]))
	idx := 1
	for {
		i := strings.IndexFunc(name[idx:], unicode.IsUpper)
		if i == -1 {
			break
		}
		idx += i
		short += strings.ToLower(string(name[idx]))
		idx++
	}
	return short
}
