package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"log"
	"os"
	"reflect"
	"sort"
	"strings"
	"unicode"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const preamble = `// Copyright (C) MongoDB, Inc. 2017-present.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

// Code generated by drivergen. DO NOT EDIT.

`

func main() {
	fs := flag.NewFlagSet("", flag.ExitOnError)
	fs.Usage = func() {
		fmt.Fprintln(fs.Output(), "drivergen is used to generate operation implementations.")
		fmt.Fprintln(fs.Output(), "usage: drivergen <type to generate> <generated file name>")
		fs.PrintDefaults()
	}
	var dryrun bool
	fs.BoolVar(&dryrun, "dryrun", false, "prints the output to stdout instead of writing to a file.")
	err := fs.Parse(os.Args[1:])
	if err == flag.ErrHelp {
		fs.Usage()
		os.Exit(0)
	}
	if err != nil {
		log.Fatalf("Could not parse flags: %v", err)
	}
	args := fs.Args()
	if len(args) < 2 {
		log.Println("Insufficient arguments specified.")
		fs.Usage()
		os.Exit(1)
	}
	filename := args[1]
	typename := args[0]

	pkgs, err := packages.Load(&packages.Config{Mode: packages.LoadAllSyntax})
	if err != nil {
		log.Fatal("Couldn't load package in current directory. Ensure the current directory contains .go files.")
	}

	if len(pkgs) != 1 {
		log.Fatal("drivergen can currently only handle directories with one package.")
	}

	var stxObj *ast.Object
	for _, sfile := range pkgs[0].Syntax {
		obj := sfile.Scope.Lookup(typename)
		if obj == nil {
			continue
		}
		stxObj = obj
		break
	}

	if stxObj == nil {
		log.Fatalf("Couldn't find %s in the package.", typename)
	}

	ts, ok := stxObj.Decl.(*ast.TypeSpec)
	if !ok {
		log.Fatalf("%s if not a struct declaration.", typename)
	}

	syntaxStruct, ok := ts.Type.(*ast.StructType)
	if !ok {
		log.Fatalf("%s is not a struct type.", typename)
	}

	obj, ok := pkgs[0].TypesInfo.Defs[ts.Name]
	if !ok {
		log.Fatalf("Couldn't find %s in types definition.", typename)
	}

	pkg := pkgs[0].Types
	t, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		log.Fatalf("Type must be a struct, but it is a %s", obj.Type().Underlying())
	}
	n := t.NumFields()
	fields := make(map[string]Field, n)
	syntaxFields := syntaxStruct.Fields.List
	if len(syntaxFields) != n {
		log.Fatalf("Mismatch number of fields between syntax and type. syntax=%d type=%d", len(syntaxFields), n)
	}

	for i := 0; i < n; i++ {
		tag := parseTag(t.Tag(i))
		if tag.Skip || tag.CommandName {
			continue
		}
		f := t.Field(i)
		sf := syntaxFields[i]
		field := Field{
			name:          f.Name(),
			fnname:        strings.Title(f.Name()),
			field:         f,
			pointerExempt: tag.PointerExempt,
			variadic:      tag.Variadic,
		}
		if tag.ExportedName != "" {
			field.fnname = tag.ExportedName
		}
		if sf.Doc != nil && len(sf.Doc.List) > 0 {
			for _, line := range sf.Doc.List {
				field.doc = append(field.doc, line.Text)
			}
		}
		if _, exists := fields[field.fnname]; exists {
			log.Fatalf("Duplicate name found: %s", field.fnname)
		}
		fields[field.fnname] = field
	}

	var b bytes.Buffer
	b.WriteString(preamble)
	fmt.Fprintln(&b, "package ", pkgs[0].Name)

	fieldslc := fieldSliceFromMap(fields)
	short := receiverName(typename)

	for _, field := range fieldslc {
		tt := field.field.Type()
		setter := field.name
		if ptt, ok := tt.(*types.Pointer); ok && !field.pointerExempt {
			tt = ptt.Elem()
			setter = "&" + field.name
		}
		param := types.TypeString(tt, types.Qualifier(func(p *types.Package) string {
			if p.String() == pkg.String() {
				return ""
			}
			return p.Name()
		}))

		if field.variadic {
			param = strings.Replace(param, "[]", "...", 1)
		}

		fmt.Fprintln(&b, strings.Join(field.doc, "\n"))
		fmt.Fprintf(&b, "func (%s %s) %s(%s %s) %s {\n", short, typename, field.fnname, field.name, param, typename)
		fmt.Fprintf(&b, "%s.%s = %s\n", short, field.name, setter)
		fmt.Fprintf(&b, "return %s\n", short)
		fmt.Fprint(&b, "}\n\n")
	}

	buf, err := imports.Process(filename, b.Bytes(), nil)
	if err != nil {
		log.Fatalf("Could not run goimports on generated source: %v", err)
	}

	if dryrun {
		os.Stdout.Write(buf)
		os.Exit(0)
	}
	file, err := os.Create(filename)
	if err != nil {
		log.Fatalf("Could not create %s: %v", filename, err)
	}

	_, err = file.Write(buf)
	if err != nil {
		log.Fatalf("Could not write to %s: %v", filename, err)
	}
}

type Field struct {
	field         *types.Var
	fnname        string
	name          string
	doc           []string
	pointerExempt bool
	variadic      bool
}

type FieldSlice []Field

var _ sort.Interface = (FieldSlice)(nil)

// fieldSliceFromMap converts a map into a FieldSlice. The returned FieldSlice is sorted by Field.name.
func fieldSliceFromMap(m map[string]Field) FieldSlice {
	fs := make(FieldSlice, 0, len(m))
	for _, field := range m {
		fs = append(fs, field)
	}
	sort.Sort(fs)
	return fs
}

func (f FieldSlice) Len() int           { return len(f) }
func (f FieldSlice) Less(i, j int) bool { return f[i].name < f[j].name }
func (f FieldSlice) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }

type Tag struct {
	Skip          bool
	ExportedName  string
	PointerExempt bool
	Variadic      bool
	CommandName   bool
}

func parseTag(str string) Tag {
	tag, ok := reflect.StructTag(str).Lookup("drivergen")
	if !ok && !strings.Contains(string(str), ":") && len(str) > 0 {
		tag = str
	}
	var t Tag
	if tag == "-" {
		t.Skip = true
		return t
	}

	for idx, s := range strings.Split(tag, ",") {
		if idx == 0 && s != "" {
			t.ExportedName = s
		}
		switch s {
		case "pointerExempt":
			t.PointerExempt = true
		case "variadic":
			t.Variadic = true
		case "commandName":
			t.CommandName = true
		}
	}

	return t
}

func receiverName(name string) string {
	if len(name) == 0 {
		return ""
	}
	short := strings.ToLower(string(name[0]))
	idx := 1
	for {
		i := strings.IndexFunc(name[idx:], unicode.IsUpper)
		if i == -1 {
			break
		}
		idx += i
		short += strings.ToLower(string(name[idx]))
		idx++
	}
	return short
}
