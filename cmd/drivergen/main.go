package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const preamble = `// Copyright (C) MongoDB, Inc. 2017-present.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

// Code generated by drivergen. DO NOT EDIT.

`

// initialize handles loading packages and retrieving the type to be code generated.
func initialize(typename string) (*types.Struct, *ast.StructType, *types.Package, []*packages.Package, error) {
	pkgs, err := packages.Load(&packages.Config{Mode: packages.LoadAllSyntax}, knownPackages[:]...)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	// We load this package by itself, not sure how to pick out the current package from a
	// []*packages.Package.
	thispkg, err := packages.Load(&packages.Config{Mode: packages.LoadAllSyntax})
	if err != nil {
		return nil, nil, nil, nil, errors.New("Couldn't load package in current directory. Ensure the current directory contains .go files.")
	}

	if len(thispkg) != 1 {
		return nil, nil, nil, nil, errors.New("drivergen can currently only handle directories with one package.")
	}

	pkgpath := thispkg[0].PkgPath
	var ppkg *packages.Package
	for _, p := range pkgs {
		if p.PkgPath != pkgpath {
			continue
		}
		ppkg = p
		break
	}

	var stxObj *ast.Object
	for _, sfile := range ppkg.Syntax {
		obj := sfile.Scope.Lookup(typename)
		if obj == nil {
			continue
		}
		stxObj = obj
		break
	}

	if stxObj == nil {
		return nil, nil, nil, nil, fmt.Errorf("Couldn't find %s in the package.", typename)
	}

	ts, ok := stxObj.Decl.(*ast.TypeSpec)
	if !ok {
		return nil, nil, nil, nil, fmt.Errorf("%s if not a struct declaration.", typename)
	}

	syntaxStruct, ok := ts.Type.(*ast.StructType)
	if !ok {
		return nil, nil, nil, nil, fmt.Errorf("%s is not a struct type.", typename)
	}

	obj, ok := ppkg.TypesInfo.Defs[ts.Name]
	if !ok {
		return nil, nil, nil, nil, fmt.Errorf("Couldn't find %s in types definition.", typename)
	}

	pkg := ppkg.Types
	t, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		return nil, nil, nil, nil, fmt.Errorf("Type must be a struct, but it is a %s", obj.Type().Underlying())
	}

	return t, syntaxStruct, pkg, pkgs, nil
}

func main() {
	fs := flag.NewFlagSet("", flag.ExitOnError)
	fs.Usage = func() {
		fmt.Fprintln(fs.Output(), "drivergen is used to generate operation implementations.")
		fmt.Fprintln(fs.Output(), "usage: drivergen <type to generate> <generated file name>")
		fs.PrintDefaults()
	}
	var dryrun bool
	fs.BoolVar(&dryrun, "dryrun", false, "prints the output to stdout instead of writing to a file.")
	var usepointers bool
	fs.BoolVar(&usepointers, "use-pointers", false, "use pointer receivers for the generated methods and returns.")
	var constructorName string
	fs.StringVar(&constructorName, "constructor", "", "the name of the constructor. No constructor will be created if this is empty.")
	err := fs.Parse(os.Args[1:])
	if err == flag.ErrHelp {
		fs.Usage()
		os.Exit(0)
	}
	if err != nil {
		log.Fatalf("Could not parse flags: %v", err)
	}
	args := fs.Args()
	if len(args) < 2 {
		log.Println("Insufficient arguments specified.")
		fs.Usage()
		os.Exit(1)
	}
	filename := args[1]
	typename := args[0]

	operation, err := NewOperation(typename, constructorName)
	if err != nil {
		log.Fatalf("Couldn't create operation: %v", err)
	}

	var b bytes.Buffer
	b.WriteString(preamble)
	fmt.Fprintln(&b, "package ", operation.Pkg.Name())

	// TODO(GODRIVER-617): Move this into it's own file and make it a template like the other generated code.
	constructor := operation.Constructor
	if constructor.Name != "" {
		var pname string
		var ptype string
		if constructor.ParamName != "" && constructor.ParamType != nil {
			pname = constructor.ParamName
			ptype = types.TypeString(constructor.ParamType.Type(), types.Qualifier(func(p *types.Package) string {
				if p == operation.Pkg {
					return ""
				}
				return p.Name()
			}))

			if constructor.Variadic {
				ptype = strings.Replace(ptype, "[]", "...", 1)
			}
		}
		fmt.Fprintf(&b, "// %s constructs and returns a new %s.\n", constructor.Name, typename)
		fmt.Fprintf(&b, "func %s(%s %s) *%s {\n", constructor.Name, pname, ptype, typename)
		fmt.Fprintf(&b, "return &%s{", typename)
		if pname != "" && ptype != "" {
			fmt.Fprintf(&b, "%s: %s", pname, pname)
		}
		fmt.Fprintln(&b, "}")
		fmt.Fprintln(&b, "}")
	}

	ed := ExecuteData{
		Receiver:   operation.Receiver,
		Type:       operation.TypeName,
		Deployment: operation.Deployment.name,
	}

	// if operation.RetryWrite != nil {
	// 	ed.RetryWrite = operation.RetryWrite.name
	// }
	if operation.ClientSession != nil {
		ed.ClientSession = operation.ClientSession.name
	}
	if operation.WriteConcern != nil {
		ed.WriteConcern = operation.WriteConcern.name
	}

	tmpls := []tmpl{
		{"Execute", executeTmpl, ed},
	}
	err = executeTemplates(&b, tmpls)
	if err != nil {
		log.Fatalf("Couldn't generate methods: %v", err)
	}

	generateSetters(&b, operation.Pkg, operation.Fields, typename, usepointers)

	buf, err := imports.Process(filename, b.Bytes(), nil)
	if err != nil {
		log.Fatalf("Could not run goimports on generated source: %v", err)
	}

	if dryrun {
		os.Stdout.Write(buf)
		os.Exit(0)
	}
	file, err := os.Create(filename)
	if err != nil {
		log.Fatalf("Could not create %s: %v", filename, err)
	}

	_, err = file.Write(buf)
	if err != nil {
		log.Fatalf("Could not write to %s: %v", filename, err)
	}
}

type tmpl struct {
	name     string
	template string
	data     interface{}
}

func executeTemplates(b *bytes.Buffer, tmpls []tmpl) error {
	for _, t := range tmpls {
		tt, err := template.New("").Parse(t.template)
		if err != nil {
			return fmt.Errorf("couldn't parse %s template: %v", t.name, err)
		}
		err = tt.Execute(b, t.data)
		if err != nil {
			return fmt.Errorf("couldn't execute %s template: %v", t.name, err)
		}
	}
	return nil
}

func generateSetters(b *bytes.Buffer, pkg *types.Package, fields map[string]Field, typename string, usepointers bool) {
	fieldslc := fieldSliceFromMap(fields)
	short := receiverName(typename)

	receiver := typename
	if usepointers {
		receiver = "*" + typename
	}
	for _, field := range fieldslc {
		tt := field.field.Type()
		setter := field.name
		if ptt, ok := tt.(*types.Pointer); ok && !field.pointerExempt {
			tt = ptt.Elem()
			setter = "&" + field.name
		}
		param := types.TypeString(tt, types.Qualifier(func(p *types.Package) string {
			if p == pkg {
				return ""
			}
			return p.Name()
		}))

		if field.variadic {
			param = strings.Replace(param, "[]", "...", 1)
		}

		fmt.Fprintln(b, strings.Join(field.doc, "\n"))
		fmt.Fprintf(b, "func (%s %s) %s(%s %s) %s {\n", short, receiver, field.fnname, field.name, param, receiver)
		if usepointers {
			fmt.Fprintf(b, "if %s == nil {\n", short)
			fmt.Fprintf(b, "%s = new(%s)", short, typename)
			fmt.Fprint(b, "}\n\n")
		}
		fmt.Fprintf(b, "%s.%s = %s\n", short, field.name, setter)
		fmt.Fprintf(b, "return %s\n", short)
		fmt.Fprint(b, "}\n\n")
	}
}

type Constructor struct {
	Name      string
	ParamName string
	ParamType *types.Var
	Variadic  bool
	Pkg       *types.Package // package for this constructor
	Typename  string         // name of the type to be constructed
}

func receiverName(name string) string {
	if len(name) == 0 {
		return ""
	}
	short := strings.ToLower(string(name[0]))
	idx := 1
	for {
		i := strings.IndexFunc(name[idx:], unicode.IsUpper)
		if i == -1 {
			break
		}
		idx += i
		short += strings.ToLower(string(name[idx]))
		idx++
	}
	return short
}

func (c Constructor) Data() ConstructorData {
	cd := ConstructorData{Name: c.Name, ParameterName: c.ParamName, Type: c.Typename}
	cd.ParameterType = types.TypeString(c.ParamType.Type(), types.Qualifier(func(p *types.Package) string {
		if p == c.Pkg {
			return ""
		}
		return p.Name()
	}))

	if c.Variadic {
		cd.ParameterType = strings.Replace(cd.ParameterType, "[]", "...", 1)
	}
	if cd.ParameterType != "" && cd.ParameterName != "" {
		cd.Parameter = true
	}
	return cd
}
