// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"path"
	"sort"

	"strings"

	"gopkg.in/yaml.v2"
)

func main() {
	log.SetFlags(0)
	log.SetPrefix(name + ": ")

	var g Generator

	g.printlnf("// Code generated by \"%s.go\"; DO NOT EDIT\n", name)

	src := g.generate()

	err := ioutil.WriteFile(fmt.Sprintf("%s.go", strings.TrimSuffix(name, "_generator")), src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) printlnf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format+"\n", args...)
}

func (g *Generator) printIfNotEqual(name string, expected interface{}) {
	g.printlnf(`if %s != %s {`, name, expected)
	g.printlnf(`t.Fatalf("expected %s to be %s, but got \"%%v\"", %s)`,
		strings.Replace(name, "\"", "\\\"", -1),
		strings.Replace(fmt.Sprintf("%v", expected), "\"", "\\\"", -1),
		name)
	g.printlnf("}")
}

func (g *Generator) printStringIfNotEqual(name string, expected string) {
	g.printIfNotEqual(name, fmt.Sprintf("\"%s\"", expected))
}

func (g *Generator) replaceCharacters(target string, old, new string) string {
	j := 0
	for i := 0; i < len(old); i++ {
		target = strings.Replace(target, string(old[i]), string(new[j]), -1)
		if j < len(new)-1 {
			j++
		}
	}

	return target
}

func (g *Generator) replaceNullCharacter(target string) string {
	return strings.Replace(target, "\x00", "\\x00", -1)
}

// EVERYTHING ABOVE IS CONSTANT BETWEEN THE GENERATORS

const name = "spec_cluster_monitor_internal_test_generator"

func (g *Generator) generate() []byte {
	g.printlnf("package core")
	g.printlnf("import \"testing\"")
	g.printlnf("import \"gopkg.in/mgo.v2/bson\"")
	g.printlnf("import \"github.com/10gen/mongo-go-driver/core/connstring\"")
	g.printlnf("import \"github.com/10gen/mongo-go-driver/core/desc\"")

	testsDir := "../specifications/source/server-discovery-and-monitoring/tests/"

	entries, err := ioutil.ReadDir(testsDir)
	if err != nil {
		log.Fatalf("error reading directory %q: %s", testsDir, err)
	}

	for _, entry := range entries {
		if !entry.IsDir() || entry.Name() == "monitoring" {
			continue
		}

		subDir := path.Join(testsDir, entry.Name())

		subentries, err := ioutil.ReadDir(subDir)
		if err != nil {
			log.Fatalf("error reading directory %q: %s", subDir, err)
		}

		for _, subentry := range subentries {
			if path.Ext(subentry.Name()) != ".yml" {
				continue
			}
			testFile := path.Join(subDir, subentry.Name())
			err := g.generateFromFile(testFile)
			if err != nil {
				log.Fatalf("error generating %q: %s", testFile, err)
			}
		}
	}

	return g.format()
}

func (g *Generator) generateFromFile(filename string) error {
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return err
	}

	var testDef testDef
	err = yaml.Unmarshal(content, &testDef)
	if err != nil {
		return err
	}

	g.printlnf("\nfunc TestClusterMonitorFSM_%s(t *testing.T) {", g.replaceCharacters(testDef.Description, " '-,", "_"))
	g.printlnf("t.Parallel()")
	g.printlnf("")
	g.printlnf("var fsm clusterMonitorFSM")

	g.printlnf("\ncs, _ := connstring.Parse(\"%s\")", testDef.Uri)
	g.printlnf("fsm.setName = cs.ReplicaSet")
	g.printlnf("if fsm.setName != \"\" {")
	g.printlnf("fsm.ClusterType = desc.ReplicaSetNoPrimary ")
	g.printlnf("}")
	g.printlnf("if len(cs.Hosts) == 1 && fsm.setName == \"\" {")
	g.printlnf("fsm.ClusterType = desc.Single")
	g.printlnf("}")
	g.printlnf("for _, host := range cs.Hosts {")
	g.printlnf("fsm.addServer(desc.Endpoint(host).Canonicalize())")
	g.printlnf("}")

	// build isMaster results from phases
	printedResponseVariables := false
	printedOutcomeVariables := false
	for i, phase := range testDef.Phases {
		for j, resp := range phase.Responses {
			if !printedResponseVariables {
				g.printlnf("\nvar serverDesc *desc.Server")
				g.printlnf("bir := &buildInfoResult{Version: \"3.4.0\", VersionArray: []uint8{3, 4, 0}}")
				g.printlnf("var imr *isMasterResult")
				printedResponseVariables = true
			}
			g.printlnf("\n// phase %d - response %d", i+1, j+1)
			g.printlnf("imr = &isMasterResult{}")
			if resp.IsMasterResult.Ok == 1 {
				g.printlnf("imr.OK = true")
			}
			if resp.IsMasterResult.ArbiterOnly {
				g.printlnf("imr.ArbiterOnly = true")
			}
			if len(resp.IsMasterResult.Arbiters) > 0 {
				g.printlnf("imr.Arbiters = []string{%s}", strings.Join(g.quoteStrings(resp.IsMasterResult.Arbiters), ","))
			}
			if resp.IsMasterResult.ElectionID != "" {
				g.printlnf("imr.ElectionID = bson.ObjectIdHex(\"%s\")", resp.IsMasterResult.ElectionID)
			}
			if resp.IsMasterResult.Hidden {
				g.printlnf("imr.Hidden = true")
			}
			if len(resp.IsMasterResult.Hosts) > 0 {
				g.printlnf("imr.Hosts = []string{%s}", strings.Join(g.quoteStrings(resp.IsMasterResult.Hosts), ","))
			}
			if resp.IsMasterResult.IsMaster {
				g.printlnf("imr.IsMaster = true")
			}
			if resp.IsMasterResult.IsReplicaSet {
				g.printlnf("imr.IsReplicaSet = true")
			}
			if resp.IsMasterResult.Me != "" {
				g.printlnf("imr.Me = \"%s\"", resp.IsMasterResult.Me)
			}
			if resp.IsMasterResult.Msg != "" {
				g.printlnf("imr.Msg = \"%s\"", resp.IsMasterResult.Msg)
			}
			if len(resp.IsMasterResult.Passives) > 0 {
				g.printlnf("imr.Passives = []string{%s}", strings.Join(g.quoteStrings(resp.IsMasterResult.Passives), ","))
			}
			if resp.IsMasterResult.Secondary {
				g.printlnf("imr.Secondary = true")
			}
			if resp.IsMasterResult.SetName != "" {
				g.printlnf("imr.SetName = \"%s\"", resp.IsMasterResult.SetName)
			}
			if resp.IsMasterResult.SetVersion != 0 {
				g.printlnf("imr.SetVersion = %d", resp.IsMasterResult.SetVersion)
			}

			g.printlnf("serverDesc = buildServerDesc(desc.Endpoint(\"%s\"), imr, bir)", resp.Host)
			g.printlnf("fsm.apply(serverDesc)")
		}

		g.printf("\n\n\n")

		g.printlnf("// phase %d outcome", i+1)
		g.printStringIfNotEqual("fsm.setName", phase.Outcome.SetName)
		topType := phase.Outcome.TopologyType
		if topType == "Unknown" {
			topType = "desc.UnknownClusterType"
		} else {
			topType = "desc." + topType
		}
		g.printIfNotEqual("fsm.ClusterType", topType)
		g.printIfNotEqual("len(fsm.Servers)", fmt.Sprintf("%d", len(phase.Outcome.Servers)))
		for _, s := range phase.Outcome.sortedServers() {
			if !printedOutcomeVariables {
				g.printlnf("\nvar ok bool")
				if !printedResponseVariables {
					g.printlnf("var serverDesc *desc.Server")
				}
				printedOutcomeVariables = true
			}
			g.printlnf("serverDesc, ok = fsm.Server(desc.Endpoint(\"%s\"))", s.name)
			g.printlnf("if !ok {")
			g.printlnf("t.Fatalf(\"server %s was not found\")", s.name)
			g.printlnf("}")
			sType := s.Type
			switch sType {
			case "Unknown", "PossiblePrimary":
				sType = "desc.UnknownServerType"
			case "RSOther":
				sType = "desc.RSMember"
			case "":
				sType = "desc.RSPrimary"
			default:
				sType = "desc." + sType
			}
			g.printIfNotEqual("serverDesc.ServerType", sType)
		}
	}

	g.printlnf("}")
	return nil
}

func (g *Generator) quoteStrings(strs []string) []string {
	var result []string
	for _, str := range strs {
		result = append(result, fmt.Sprintf("\"%s\"", str))
	}
	return result
}

type testDef struct {
	Description string  `yaml:"description"`
	Uri         string  `yaml:"uri"`
	Phases      []phase `yaml:"phases"`
}

type outcome struct {
	Servers      map[string]outcomeServer `yaml:"servers"`
	SetName      string                   `yaml:"setName"`
	TopologyType string                   `yaml:"topologyType"`
}

func (o *outcome) sortedServers() []outcomeServer {
	var outcomeServers sortableOutcomeServers
	for key, s := range o.Servers {
		outcomeServers = append(outcomeServers, outcomeServer{
			name:    key,
			SetName: s.SetName,
			Type:    s.Type,
		})
	}

	sort.Sort(outcomeServers)
	return outcomeServers
}

type outcomeServer struct {
	SetName string `yaml:"setName"`
	Type    string `yaml:"type"`

	name string
}

type sortableOutcomeServers []outcomeServer

func (s sortableOutcomeServers) Len() int {
	return len(s)
}
func (s sortableOutcomeServers) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}
func (s sortableOutcomeServers) Less(i, j int) bool {
	return s[i].name < s[j].name
}

type phase struct {
	Outcome   outcome         `yaml:"outcome"`
	Responses []phaseResponse `yaml:"responses"`
}

type phaseResponse struct {
	Host           string
	IsMasterResult *phaseServer
}

func (p *phaseResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	arrayIfaceToArrayString := func(items []interface{}) []string {
		var strs []string
		for _, item := range items {
			strs = append(strs, item.(string))
		}
		return strs
	}

	getInt := func(iface interface{}) int {
		switch typed := iface.(type) {
		case int:
			return typed
		case float64:
			return int(typed)
		default:
			panic("ahahah")
		}
	}

	var parts []interface{}
	if err := unmarshal(&parts); err != nil {
		return err
	}

	p.Host = parts[0].(string)
	var ps phaseServer
	for key, value := range parts[1].(map[interface{}]interface{}) {
		switch key {
		case "arbiterOnly":
			ps.ArbiterOnly = value.(bool)
		case "arbiters":
			ps.Arbiters = arrayIfaceToArrayString(value.([]interface{}))
		case "electionId":
			oidMap := value.(map[interface{}]interface{})
			value = oidMap["$oid"]
			ps.ElectionID = value.(string)
		case "hidden":
			ps.Hidden = value.(bool)
		case "hosts":
			ps.Hosts = arrayIfaceToArrayString(value.([]interface{}))
		case "ismaster":
			ps.IsMaster = value.(bool)
		case "isreplicaset":
			ps.IsReplicaSet = value.(bool)
		case "me":
			ps.Me = value.(string)
		case "msg":
			ps.Msg = value.(string)
		case "ok":
			ps.Ok = getInt(value)
		case "passives":
			ps.Passives = arrayIfaceToArrayString(value.([]interface{}))
		case "secondary":
			ps.Secondary = value.(bool)
		case "setName":
			ps.SetName = value.(string)
		case "setVersion":
			ps.SetVersion = getInt(value)
		}
	}
	p.IsMasterResult = &ps
	return nil
}

type phaseServer struct {
	ArbiterOnly  bool
	Arbiters     []string
	ElectionID   string
	Hidden       bool
	Hosts        []string
	IsMaster     bool
	IsReplicaSet bool
	Me           string
	Msg          string
	Ok           int
	Passives     []string
	Secondary    bool
	SetName      string
	SetVersion   int
}
