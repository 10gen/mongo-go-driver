// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"io/ioutil"
	"log"
	"path"
	"strings"

	"gopkg.in/yaml.v2"
)

func main() {
	log.SetFlags(0)
	log.SetPrefix(name + ": ")

	var g Generator

	g.printlnf("// Code generated by \"%s.go\"; DO NOT EDIT\n", name)

	src := g.generate()

	err := ioutil.WriteFile(fmt.Sprintf("%s.go", strings.TrimSuffix(name, "_generator")), src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) printlnf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format+"\n", args...)
}

// EVERYTHING ABOVE IS CONSTANT BETWEEN THE GENERATORS

const name = "selector_spec_test_generator"

func (g *Generator) generate() []byte {

	testsDir := "../specifications/source/server-selection/tests/server_selection/"

	var tests []*testDef

	entries, err := ioutil.ReadDir(testsDir)
	if err != nil {
		log.Fatalf("error reading directory %q: %s", testsDir, err)
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		subDir := path.Join(testsDir, entry.Name())

		subentries, err := ioutil.ReadDir(subDir)
		if err != nil {
			log.Fatalf("error reading directory %q: %s", subDir, err)
		}

		for _, subentry := range subentries {
			if !subentry.IsDir() || subentry.Name() == "write" {
				continue
			}

			subentryDir := path.Join(subDir, subentry.Name())

			testEntries, err := ioutil.ReadDir(subentryDir)
			if err != nil {
				log.Fatalf("error reading directory %q: %s", subentryDir, err)
			}

			for _, testentry := range testEntries {
				if path.Ext(testentry.Name()) != ".yml" || strings.HasPrefix(testentry.Name(), "PossiblePrimary") {
					continue
				}
				testFile := path.Join(subentryDir, testentry.Name())
				test, err := g.loadTest(testFile)
				if err != nil {
					log.Fatalf("error loading test from file %q: %s", testFile, err)
				}
				test.Name = fmt.Sprintf("%s_%s_%s", entry.Name(), subentry.Name(), testentry.Name()[:len(testentry.Name())-4])
				tests = append(tests, test)
			}
		}
	}

	tmpl, err := g.getTemplate()
	if err != nil {
		log.Fatalf("error loading template: %s", err)
	}

	tmpl.Execute(&g.buf, tests)

	return g.format()
}

func (g *Generator) loadTest(filename string) (*testDef, error) {
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	var testDef testDef
	err = yaml.Unmarshal(content, &testDef)
	if err != nil {
		return nil, err
	}

	return &testDef, nil
}

func (g *Generator) getTemplate() (*template.Template, error) {
	content := `package readpref_test

import (
	"testing"

    "github.com/10gen/mongo-go-driver/desc"
    . "github.com/10gen/mongo-go-driver/readpref"
   	"github.com/stretchr/testify/require"
)
{{range .}}
func TestReadPref_{{.Name}}(t *testing.T) {
	t.Parallel()
	
	require := require.New(t)
    subject := New({{.ReadPreference.Mode}}Mode,
        {{range .ReadPreference.TagSets}}desc.NewTagSet({{range $key, $value := .}}
			"{{$key}}", "{{$value}}",
		{{end}}),
        {{end}})

	{{with .TopologyDescription}}
    cluster := &desc.Cluster{
        Type: desc.{{if eq .Type "Unknown"}}UnknownClusterType{{else}}{{.Type}}{{end}},
        Servers: []*desc.Server{
        {{range .Servers}}  &desc.Server{
                Endpoint: desc.Endpoint("{{.Address}}"),
                Type: desc.{{.Type}},
                Tags: desc.NewTagSet({{range $key, $value := .Tags}}
                    "{{$key}}", "{{$value}}",
                {{end}}),
            },
            {{end}}
        },
    }
	{{end}}

    result, err := SelectServer(subject, cluster, cluster.Servers)
    require.NoError(err)
    require.Len(result, {{ len .SuitableServers }})
	{{ range .SuitableServers }}require.Contains(
		result,
		&desc.Server{
			Endpoint: desc.Endpoint("{{.Address}}"),
			Type: desc.{{.Type}},
			Tags: desc.NewTagSet({{range $key, $value := .Tags}}
				"{{$key}}", "{{$value}}",
			{{end}}),
		},
	)
	{{end}}}
{{end}}
`
	tmpl, err := template.New("").Parse(content)
	if err != nil {
		return nil, err
	}
	return tmpl, nil
}

type testDef struct {
	Name string

	TopologyDescription topDesc      `yaml:"topology_description"`
	Operation           string       `yaml:"operation"`
	ReadPreference      readPref     `yaml:"read_preference"`
	SuitableServers     []serverDesc `yaml:"suitable_servers"`
	InLatencyWindow     []serverDesc `yaml:"in_latency_window"`
}

type topDesc struct {
	Type    string       `yaml:"type"`
	Servers []serverDesc `yaml:"servers"`
}

type serverDesc struct {
	Address       string            `yaml:"address"`
	AverageRTTMsg int               `yaml:"avg_rtt_ms"`
	Type          string            `yaml:"type"`
	Tags          map[string]string `yaml:"tags"`
}

type readPref struct {
	Mode    string              `yaml:"mode"`
	TagSets []map[string]string `yaml:"tag_sets"`
}
