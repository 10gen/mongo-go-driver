description: "operation timeouts do not cause connection churn"

schemaVersion: "1.9"

runOnRequirements:
  - minServerVersion: "4.4"
    # TODO(SERVER-96344): when using failpoints mongos returns MaxTimeMSExpired 
    # after maxTimeMS, whereas mongod returns MaxTimeMSExpired after 
    # max(blockTimeMS, maxTimeMS). Until this ticket is resolved, these tests 
    # will not pass on sharded clusters.
    topologies: ["standalone", "replicaset"]

createEntities:
  - client:
      id: &failPointClient failPointClient
      useMultipleMongoses: false
  - client:
      id: &client client
      uriOptions:  
        maxPoolSize: 1
      useMultipleMongoses: false
      observeEvents:
        - commandFailedEvent
        - commandSucceededEvent
        - connectionCheckedOutEvent
        - connectionCheckedInEvent
        - connectionClosedEvent
  - database:
      id: &database test
      client: *client
      databaseName: *database
  - collection:
      id: &collection coll
      database: *database
      collectionName: *collection

initialData:
  - collectionName: *collection
    databaseName: *database
    documents: []

tests:
  - description: "write op with successful pending read"
    operations:
      # Create a failpoint to block first op
      - name: failPoint
        object: testRunner
        arguments:
          client: *failPointClient
          failPoint:
            configureFailPoint: failCommand
            mode: { times: 1 }
            data:
              failCommands: ["insert"]
              blockConnection: true
              blockTimeMS: 750

      # Execute op with timeout < block time
      - name: insertOne
        object: *collection
        arguments:
          timeoutMS: 500
          document: { _id: 3, x: 1 }
        expectError:
          isTimeoutError: true

      # Execute a subsequent operation to complete the read when checking out 
      # the single available connection.
      - name: findOne
        object: *collection
        arguments:
          filter: { _id: 1 }

    expectEvents:
      - client: *client
        events:
          - commandFailedEvent:
              commandName: insert
          - commandSucceededEvent:
              commandName: find
      - client: *client
        eventType: cmap
        events: 
          - connectionCheckedOutEvent: {} # insert
          - connectionCheckedInEvent: {}  # insert fails
          - connectionCheckedOutEvent: {} # find
          - connectionCheckedInEvent: {}  # find succeeds

  - description: "write op with unsuccessful pending read"
    operations:
      # Create a failpoint to block first op
      - name: failPoint
        object: testRunner
        arguments:
          client: *failPointClient
          failPoint:
            configureFailPoint: failCommand
            mode: { times: 1 }
            data:
              failCommands: ["insert"]
              blockConnection: true
              blockTimeMS: 750

      # Execute op with timeout < block time
      - name: insertOne
        object: *collection
        arguments:
          timeoutMS: 50
          document: { _id: 3, x: 1 }
        expectError:
          isTimeoutError: true

      # The pending read should fail.
      - name: insertOne
        object: *collection
        arguments:
          timeoutMS: 500
          document: { _id: 3, x: 1 }
        expectError:
          isTimeoutError: true

    expectEvents:
      - client: *client
        events:
          - commandFailedEvent:
              commandName: insert
          # There is not a second failed event since we T/O attempting to 
          # check out the connection for the second operation.
      - client: *client
        eventType: cmap
        events: 
          - connectionCheckedOutEvent: {} # first insert
          - connectionCheckedInEvent: {}  # first insert fails
          - connectionClosedEvent:        # second insert T/O pending read in C/O, closes
              reason: error

  - description: "read op with successful pending read"
    operations:
      # Create a failpoint to block first op 
      - name: failPoint
        object: testRunner
        arguments:
          client: *failPointClient
          failPoint:
            configureFailPoint: failCommand
            mode: { times: 1 }
            data:
              failCommands: ["find"]
              blockConnection: true
              blockTimeMS: 750

      # Execute op with timeout < block time 
      - name: findOne
        object: *collection
        arguments:
          timeoutMS: 50
          filter: { _id: 1 }
        expectError:
          isTimeoutError: true

      # Execute a subsequent operation to complete the read when checking out 
      # the single available connection.
      - name: findOne
        object: *collection
        arguments:
          filter: { _id: 1 }

    expectEvents:
      - client: *client
        events:
          - commandFailedEvent:
              commandName: find
          - commandSucceededEvent:
              commandName: find
      - client: *client
        eventType: cmap
        events: 
          - connectionCheckedOutEvent: {} # first find 
          - connectionCheckedInEvent: {}  # first find fails
          - connectionCheckedOutEvent: {} # second find
          - connectionCheckedInEvent: {}  # second find succeeds

  - description: "read op with unsuccessful pending read"
    operations:
      # Create a failpoint to block first op 
      - name: failPoint
        object: testRunner
        arguments:
          client: *failPointClient
          failPoint:
            configureFailPoint: failCommand
            mode: { times: 1 }
            data:
              failCommands: ["find"]
              blockConnection: true
              blockTimeMS: 750

      # Execute op with timeout < block time 
      - name: findOne
        object: *collection
        arguments:
          timeoutMS: 50
          filter: { _id: 1 }
        expectError:
          isTimeoutError: true

      # The pending read should fail.
      - name: findOne
        object: *collection
        arguments:
          timeoutMS: 500
          filter: { _id: 1 }
        expectError:
          isTimeoutError: true

    expectEvents:
      - client: *client
        events:
          - commandFailedEvent:
              commandName: find
          # There is not a second failed event since we T/O attempting to 
          # check out the connection for the second operation.
      - client: *client
        eventType: cmap
        events: 
          - connectionCheckedOutEvent: {} # first find 
          - connectionCheckedInEvent: {}  # first find fails
          - connectionClosedEvent:        # second find T/O pending read in C/O, closes
              reason: error
