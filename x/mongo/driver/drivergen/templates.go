package drivergen

import "text/template"

// commandCollectionDatabaseTmpl is the template used to set the command name when the command can
// apply to either a collection or a database.
var commandCollectionDatabaseTmpl = template.Must(template.New("").Parse(
	`header := bsoncore.Value{Type: bsontype.String, Data: bsoncore.AppendString(nil, {{$.ShortName}}.collection)}
if {{$.ShortName}}.collection == "" {
	header = bsoncore.Value{Type: bsontype.Int32, Data: []byte{0x01, 0x00, 0x00, 0x00}}
}
dst = bsoncore.AppendValueElement(dst, "{{$.Command.Name}}", header)
`))

// commandCollectionTmpl is the template used to set the command name when the parameter will be a
// collection.
var commandCollectionTmpl = template.Must(template.New("").Parse(
	`dst = bsoncore.AppendStringElement(dst, "{{$.Command.Name}}", {{$.ShortName}}.collection)
`))

var commandParamDocumentTmpl = template.Must(template.New("").Parse(`if {{$.ShortName}}.{{$.Name}} != nil {
	dst = bsoncore.AppendDocumentElement(dst, "{{$.ParameterName}}", {{$.ShortName}}.{{$.Name}})
}
`))

var commandParamValueTmpl = template.Must(template.New("").Parse(`if {{$.ShortName}}.{{$.Name}}.Type != bsontype.Type(0) {
	dst = bsoncore.AppendValueElement(dst, "{{$.ParameterName}}", {{$.ShortName}}.{{$.Name}})
}
`))

var commandParamInt32Tmpl = template.Must(template.New("").Parse(`if {{$.ShortName}}.{{$.Name}} != nil {
	dst = bsoncore.AppendInt32Element(dst, "{{$.ParameterName}}", *{{$.ShortName}}.{{$.Name}})
}
`))

var commandParamInt64Tmpl = template.Must(template.New("").Parse(`if {{$.ShortName}}.{{$.Name}} != nil {
	dst = bsoncore.AppendInt64Element(dst, "{{$.ParameterName}}", *{{$.ShortName}}.{{$.Name}})
}
`))

var commandParamDoubleTmpl = template.Must(template.New("").Parse(`if {{$.ShortName}}.{{$.Name}} != nil {
	dst = bsoncore.AppendDoubleElement(dst, "{{$.ParameterName}}", *{{$.ShortName}}.{{$.Name}})
}
`))

var commandParamBooleanTmpl = template.Must(template.New("").Parse(`if {{$.ShortName}}.{{$.Name}} != nil {
	dst = bsoncore.AppendBooleanElement(dst, "{{$.ParameterName}}", *{{$.ShortName}}.{{$.Name}})
}
`))

var commandParamStringTmpl = template.Must(template.New("").Parse(`if {{$.ShortName}}.{{$.Name}} != nil {
	dst = bsoncore.AppendStringElement(dst, "{{$.ParameterName}}", *{{$.ShortName}}.{{$.Name}})
}
`))

var responseFieldInt64Tmpl = template.Must(template.New("").Parse(`
	case "{{$.ResponseName}}":
		var ok bool
		{{$.ResponseShortName}}.{{$.Field}}, ok = element.Value().Int64OK()
		if !ok {
			err = fmt.Errorf("response field '{{$.ResponseName}}' is type int64, but received BSON type %s", element.Value().Type)
		}
`))

var responseFieldInt32Tmpl = template.Must(template.New("").Parse(`
	case "{{$.ResponseName}}":
		var ok bool
		{{$.ResponseShortName}}.{{$.Field}}, ok = element.Value().Int32OK()
		if !ok {
			err = fmt.Errorf("response field '{{$.ResponseName}}' is type int32, but received BSON type %s", element.Value().Type)
		}
`))

const typeTemplate string = `// Copyright (C) MongoDB, Inc. 2019-present.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

// Code generated by operationgen. DO NOT EDIT.

package {{$.PackageName}}

import "go.mongodb.org/mongo-driver/x/mongo/driver"

type {{$.Name}} struct {
{{range $name, $field := $.Request}}	{{$name}} {{$field.DeclarationType}}
{{end}}{{range $builtin := $.Properties.Builtins}}	{{$builtin.ReferenceName}} {{$builtin.Type}}
{{end}}{{if $.Properties.Retryable.Mode}}	retry *driver.RetryMode{{end}}
	result {{$.ResultType}}
}

{{if $.Response.Name}}
type {{$.Response.Name}} struct {
{{range $name, $field := $.Response.Field}}// {{$field.Documentation}}
	{{$.Title $name}} {{$field.Type}}
{{end}}
}

// Build{{$.Response.Name}} constructs a {{$.Response.Name}} from the provided response document
// and server.
func Build{{$.Response.Name}}(response bsoncore.Document, srvr driver.Server) ({{$.Response.Name}}, error) {
	elements, err := response.Elements()
	if err != nil {
		return {{$.Response.Name}}{}, err
	}
	{{$.Response.ShortName}} := {{$.Response.Name}}{}
	for _, element := range elements {
		switch element.Key() {
		{{$.Response.BuildMethod}}
		}
	}
	return {{$.Response.ShortName}}, nil
}
{{end}}

// New{{$.Name}} constructs and returns a new {{$.Name}}.
func New{{$.Name}}({{$.ConstructorParameters}}) *{{$.Name}} {
	return &{{$.Name}}{
{{range $field := $.ConstructorFields}}		{{$field}}
{{end}}
	}
}

// Result returns the result of executing this operation.
func ({{$.ShortName}} *{{$.Name}}) Result() {{$.ResultType}} { return {{$.ShortName}}.result }

func ({{$.ShortName}} *{{$.Name}}) processResponse(response bsoncore.Document, srvr driver.Server) error {
{{if $.Response.Name}}
	var err error
	{{$.ShortName}}.result, err = Build{{$.Response.Name}}(response, srvr)
	return err
{{end}}
{{if eq $.Response.Type "batch cursor"}}
	return nil
{{end}}
}

func ({{$.ShortName}} *{{$.Name}}) Execute(ctx context.Context) error {
	if {{$.ShortName}}.deployment == nil {
		return errors.New("{{$.Name}} must have a Deployment set before Execute can be called.")
	}
{{if $.Properties.Batches}}		batches := &driver.Batches{
			Identifier: "{{$.Properties.Batches.Identifier}}",
			Documents: {{$.ShortName}}.{{$.Properties.Batches.Documents}},
			Ordered: {{$.ShortName}}.{{$.Properties.Batches.Ordered}},
}{{end}}
{{with $builtins := $.Properties.BuiltinsMap}}
	return driver.Operation{
		CommandFn: {{$.ShortName}}.command,
		ProcessResponseFn: {{$.ShortName}}.processResponse,{{if $.Properties.Batches}}
		Batches: batches,{{end}}
{{if $.Properties.Retryable.Mode}}	RetryMode: {{$.ShortName}}.retry,{{end}}
{{range $b := $.Properties.ExecuteBuiltins}}{{$b.ExecuteName}}: {{$.ShortName}}.{{$b.ReferenceName}},
{{end}}
	}.Execute(ctx, nil)
{{end}}
}

func ({{$.ShortName}} *{{$.Name}}) command(dst []byte, desc description.SelectedServer) ([]byte, error) {
	{{$.CommandMethod}}
	return dst, nil
}

{{range $name, $field := $.Request}}
{{$.EscapeDocumentation $field.Documentation}}
func ({{$.ShortName}} *{{$.Name}}) {{$.Title $name}}({{$name}} {{$field.ParameterType}}) *{{$.Name}} {
	if {{$.ShortName}} == nil {
		{{$.ShortName}} = new({{$.Name}})
	}

	{{$.ShortName}}.{{$name}} = {{if $field.PointerType}}&{{end}}{{$name}}
	return {{$.ShortName}}
}

{{end}}

{{range $builtin := $.Properties.Builtins}}
{{$.EscapeDocumentation $builtin.Documentation}}
func ({{$.ShortName}} *{{$.Name}}) {{$builtin.SetterName}}({{$builtin.ReferenceName}} {{$builtin.Type}}) *{{$.Name}} {
	if {{$.ShortName}} == nil {
		{{$.ShortName}} = new({{$.Name}})
	}

	{{$.ShortName}}.{{$builtin.ReferenceName}} = {{$builtin.ReferenceName}}
	return {{$.ShortName}}
}
{{end}}

{{if $.Properties.Retryable.Mode}}
// Retry enables retryable writes for this operation. Retries are not handled automatically,
// instead a boolean is returned from Execute and SelectAndExecute that indicates if the
// operation can be retried. Retrying is handled by calling RetryExecute.
func ({{$.ShortName}} *{{$.Name}}) Retry(retry driver.RetryMode) *{{$.Name}} {
	if {{$.ShortName}} == nil {
		{{$.ShortName}} = new({{$.Name}})
	}

	{{$.ShortName}}.retry = &retry
	return {{$.ShortName}}
}
{{end}}
`
