// Copyright (C) MongoDB, Inc. 2017-present.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

// Code generated by drivergen. DO NOT EDIT.

package driverx

import (
	"context"
	"errors"

	"go.mongodb.org/mongo-driver/mongo/readpref"
	"go.mongodb.org/mongo-driver/mongo/writeconcern"
	"go.mongodb.org/mongo-driver/x/bsonx/bsoncore"
	"go.mongodb.org/mongo-driver/x/mongo/driver/session"
	"go.mongodb.org/mongo-driver/x/network/description"
)

// Insert constructs and returns a new InsertOperation.
func Insert(documents ...bsoncore.Document) *InsertOperation {
	return &InsertOperation{documents: documents}
}

// Select retrieves a server to be used when executing an operation.
func (io *InsertOperation) Select(ctx context.Context) (Server, error) {
	if io.d == nil {
		return nil, errors.New("InsertOperation must have a Deployment set before Select can be called.")
	}

	return io.d.SelectServer(ctx, createReadPrefSelector(readpref.Primary(), io.serverSelector))
}

// SelectAndExecute selects a server and runs this operation against it.
func (io *InsertOperation) SelectAndExecute(ctx context.Context) error {
	srvr, err := io.Select(ctx)
	if err != nil {
		return err
	}

	return io.Execute(ctx, srvr)
}

// Execute runs this operation against the provided server.
// If the error returned is retryable, either SelectAndRetryExecute or Select followed by
// RetryExecute can be called to retry this operation.
func (io *InsertOperation) Execute(ctx context.Context, srvr Server) error {
	if io.d == nil {
		return errors.New("InsertOperation must have a Deployment set before Execute can be called.")
	}
	conn, err := srvr.Connection(ctx)
	if err != nil {
		return err
	}
	defer conn.Close()

	if io.client != nil && !writeconcern.AckWrite(io.writeConcern) {
		return errors.New("session provided for an unacknowledged write")
	}

	desc := conn.Description()

	retryable := (io.retry != nil && *io.retry == true) && retrySupported(io.d.Description(), desc, io.client, io.writeConcern)
	if retryable {
		// io.client must not be nil or retrySupported would have returned false
		io.client.RetryWrite = true
		io.client.IncrementTxnNumber()
	}

	return io.execute(ctx, conn)
}

// SelectAndExecute selects a server and retries this operation against it. This is a convenience
// method and should only be called after a retryable error is returned from SelectAndExecute or
// Execute.
func (io *InsertOperation) SelectAndRetryExecute(ctx context.Context, original error) error {
	if io.d == nil {
		return errors.New("InsertOperation must have a Deployment set before RetryExecute can be called.")
	}
	srvr, err := io.Select(ctx)

	// Return original error if server selection fails.
	if err != nil {
		return original
	}

	return io.RetryExecute(ctx, srvr, original)
}

// RetryExecute retries this operation against the provided server. This method should only be
// called after a retryable error is returned from either SelectAndExecute or Execute.
func (io *InsertOperation) RetryExecute(ctx context.Context, srvr Server, original error) error {
	conn, err := srvr.Connection(ctx)
	// Return original error if connection retrieval fails or new server does not support retryable writes.

	if err != nil || conn == nil || !retrySupported(io.d.Description(), conn.Description(), io.client, io.writeConcern) {
		return original
	}

	defer conn.Close()

	return io.execute(ctx, conn)
}

// BypassDocumentValidation allows the operation to opt-out of document level validation. Valid
// for server versions >= 3.2. For servers < 3.2, this setting is ignored.
func (io *InsertOperation) BypassDocumentValidation(bypassDocumentValidation bool) *InsertOperation {
	if io == nil {
		io = new(InsertOperation)
	}

	io.bypassDocumentValidation = &bypassDocumentValidation
	return io
}

// Session sets the session for this operation.
func (io *InsertOperation) Session(client *session.Client) *InsertOperation {
	if io == nil {
		io = new(InsertOperation)
	}

	io.client = client
	return io
}

// ClusterClock sets the cluster clock for this operation.
func (io *InsertOperation) ClusterClock(clock *session.ClusterClock) *InsertOperation {
	if io == nil {
		io = new(InsertOperation)
	}

	io.clock = clock
	return io
}

// Deployment sets the deployment to use for this operation.
func (io *InsertOperation) Deployment(d Deployment) *InsertOperation {
	if io == nil {
		io = new(InsertOperation)
	}

	io.d = d
	return io
}

// Documents adds documents to this operation that will be inserted when this operation is
// executed.
func (io *InsertOperation) Documents(documents ...bsoncore.Document) *InsertOperation {
	if io == nil {
		io = new(InsertOperation)
	}

	io.documents = documents
	return io
}

// Namespace sets the database and collection to run this operation against.
func (io *InsertOperation) Namespace(ns Namespace) *InsertOperation {
	if io == nil {
		io = new(InsertOperation)
	}

	io.ns = ns
	return io
}

// Ordered sets ordered. If true, when a write fails, the operation will return the error, when
// false write failures do not stop execution of the operation.
func (io *InsertOperation) Ordered(ordered bool) *InsertOperation {
	if io == nil {
		io = new(InsertOperation)
	}

	io.ordered = &ordered
	return io
}

// Retry enables retryable writes for this operation. Retries are not handled automatically,
// instead a boolean is returned from Execute and SelectAndExecute that indicates if the
// operation can be retried. Retrying is handled by calling RetryExecute.
func (io *InsertOperation) Retry(retry bool) *InsertOperation {
	if io == nil {
		io = new(InsertOperation)
	}

	io.retry = &retry
	return io
}

// ServerSelector sets the selector used to retrieve a server.
func (io *InsertOperation) ServerSelector(serverSelector description.ServerSelector) *InsertOperation {
	if io == nil {
		io = new(InsertOperation)
	}

	io.serverSelector = serverSelector
	return io
}

// WriteConcern sets the write concern for this operation.
func (io *InsertOperation) WriteConcern(writeConcern *writeconcern.WriteConcern) *InsertOperation {
	if io == nil {
		io = new(InsertOperation)
	}

	io.writeConcern = writeConcern
	return io
}
