package driverx

import (
	"context"
	"errors"

	"go.mongodb.org/mongo-driver/mongo/writeconcern"
	"go.mongodb.org/mongo-driver/x/bsonx/bsoncore"
	"go.mongodb.org/mongo-driver/x/mongo/driver/session"
	"go.mongodb.org/mongo-driver/x/network/description"
	"go.mongodb.org/mongo-driver/x/network/result"
)

//go:generate drivergen -use-pointers -constructor Insert InsertOperation insert.generated.go

var msgInsert = [...]byte{'d', 'o', 'c', 'u', 'm', 'e', 'n', 't', 's', 0x00}

type InsertOperation struct {
	insert struct{} `drivergen:",commandName"`

	// Documents adds documents to this operation that will be inserted when this operation is
	// executed.
	documents []bsoncore.Document `drivergen:",variadic,constructorArg"`

	// Ordered sets ordered. If true, when a write fails, the operation will return the error, when
	// false write failures do not stop execution of the operation.
	ordered *bool

	// WriteConcern sets the write concern for this operation.
	writeConcern *writeconcern.WriteConcern `drivergen:",pointerExempt"`

	// BypassDocumentValidation allows the operation to opt-out of document level validation. Valid
	// for server versions >= 3.2. For servers < 3.2, this setting is ignored.
	bypassDocumentValidation *bool

	// Retry enables retryable writes for this operation. Retries are not handled automatically,
	// instead a boolean is returned from Execute and SelectAndExecute that indicates if the
	// operation can be retried. Retrying is handled by calling RetryExecute.
	retry *RetryMode `drivergen:",retryableWrite"`

	// Namespace sets the database and collection to run this operation against.
	ns Namespace `drivergen:"Namespace"`

	// Deployment sets the deployment to use for this operation.
	d Deployment `drivergen:"Deployment"`

	// ServerSelector sets the selector used to retrieve a server.
	serverSelector description.ServerSelector

	// Session sets the session for this operation.
	client *session.Client `drivergen:"Session,pointerExempt"`

	// ClusterClock sets the cluster clock for this operation.
	clock *session.ClusterClock `drivergen:"ClusterClock,pointerExempt"`

	result result.Insert `drivergen:"-"`
}

// Result returns the result from executing this operation. This should only be called after Execute
// and any retries.
//
// TODO(GODRIVER-617): This should be generated by drivergen.
func (io *InsertOperation) Result() result.Insert {
	if io == nil {
		return result.Insert{}
	}
	return io.result
}

func (io *InsertOperation) processResponse(response bsoncore.Document, _ Server) error {
	if n, ok := response.Lookup("n").AsInt64OK(); ok {
		io.result.N += int(n)
	}
	return nil
}

// TODO(GODRIVER-617): This should be generated by drivergen.
func (io *InsertOperation) retryable(desc description.Server) RetryType {
	if (io.retry != nil && (*io.retry).Enabled()) &&
		retrySupported(io.d.Description(), desc, io.client, io.writeConcern) {
		return RetryWrite
	}
	return 0
}

// TODO(GODRIVER-617): This should be generated by drivergen.
func (io *InsertOperation) Execute(ctx context.Context) error {
	if io.d == nil {
		return errors.New("InsertOperation must have a Deployment set before Select can be called.")
	}

	if io.client != nil && !writeconcern.AckWrite(io.writeConcern) {
		return errors.New("session provided for an unacknowledged write")
	}
	if io.ns.Collection == "" || io.ns.DB == "" {
		return errors.New("Collection and DB must be of non-zero length")
	}
	return OperationContext{
		CommandFn:  io.command,
		Deployment: io.d,
		Database:   io.ns.DB,

		ProcessResponseFn: io.processResponse,
		RetryableFn:       io.retryable,

		Selector:     io.serverSelector,
		WriteConcern: io.writeConcern,

		Client: io.client,
		Clock:  io.clock,

		RetryMode: io.retry,
		Batches: &Batches{
			Identifier: "documents",
			Documents:  io.documents,
			Ordered:    io.ordered,
		},
	}.Execute(ctx)
}

// TODO(GODRIVER-617): This should be generated by drivergen.
func (io *InsertOperation) command(dst []byte, desc description.SelectedServer) ([]byte, error) {
	dst = bsoncore.AppendStringElement(dst, "insert", io.ns.Collection)

	if io.ordered != nil {
		dst = bsoncore.AppendBooleanElement(dst, "ordered", *io.ordered)
	}
	if io.bypassDocumentValidation != nil {
		dst = bsoncore.AppendBooleanElement(dst, "bypassDocumentValidation", *io.bypassDocumentValidation)
	}

	return dst, nil
}
